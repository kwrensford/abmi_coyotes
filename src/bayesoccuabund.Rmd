---
title: "Abundance Modelling"
author: "Kwasi Wrensford"
date: "2025-11-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r}
library(vroom)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(forcats)
library(lubridate)
library(MASS)
library(hms)
library(unmarked)
library(camtrapR)
library(overlap)
library(stars)
library(sf)
library(terra)
library(rstan)
library(Rcpp)
library(stringr)
library(mgcv)
library(cowplot)
library(gridExtra)
library(ubms)
library(spAbundance)
library(spOccupancy)
library(MCMCvis)
library(forestplot)
```

```{r}
getwd()
```

#Formatting count data

```{r}

coyotecounts <- as.matrix(read.csv("data/coyotecounts.csv"))
lynxcounts <- as.matrix(read.csv("data/lynxcounts.csv"))
martencounts <- as.matrix(read.csv("data/martencounts.csv"))
fishercounts <- as.matrix(read.csv("data/fishercounts.csv"))
```

#Visualizing overlap
```{r}
count_list <- list(
  coyote = coyotecounts,
  lynx   = lynxcounts,
  marten = martencounts,
  fisher = fishercounts
)

site_id <- covars$location

sites_species <- c(
  coyote = sum(rowSums(coyotecounts, na.rm = TRUE) > 0),
  lynx   = sum(rowSums(lynxcounts, na.rm = TRUE) > 0),
  marten = sum(rowSums(martencounts, na.rm = TRUE) > 0),
  fisher = sum(rowSums(fishercounts, na.rm = TRUE) > 0)
)

site_counts <- map_df(names(count_list), function(sp) {
  mat <- count_list[[sp]]
  data.frame(
    site = site_id,
    species = sp,
    detections = rowSums(mat, na.rm = TRUE)
  )
})

ggplot(site_counts, aes(x = site, y = detections)) +
  geom_col() +
  facet_wrap(~ species, scales = "free_y") +
  theme_bw() +
  labs(
    title = "Detections per Site for Each Species",
    x = "Site ID",
    y = "Total Detections"
  )
```
```{r}
presence_list <- lapply(count_list, function(mat) {
  as.numeric(rowSums(mat, na.rm = TRUE) > 0)
})

presence_df <- data.frame(
  site = site_id,
  coyote = presence_list$coyote,
  lynx   = presence_list$lynx,
  marten   = presence_list$marten,
  fisher = presence_list$fisher
)

# get species names
sp <- names(count_list)

# function to count sites where sp occurs alone
alone_counts <- sapply(sp, function(s) {
  this_present  <- presence_df[[s]] == 1
  others_absent <- rowSums(presence_df[sp[sp != s]]) == 0
  sum(this_present & others_absent)
})

alone_counts

pairwise_counts <- function(matA, matB, spA, spB) {

  A_present <- rowSums(matA, na.rm =TRUE) > 0
  B_present <- rowSums(matB, na.rm =TRUE) > 0

  data.frame(
    sp1 = spA,
    sp2 = spB,
    both_present = sum(A_present & B_present),
    only_sp1     = sum(A_present & !B_present),
    only_sp2     = sum(!A_present & B_present)
  )
}

out1 <- pairwise_counts(coyotecounts, lynxcounts,   "coyote", "lynx")
out2 <- pairwise_counts(coyotecounts, martencounts, "coyote", "marten")
out3 <- pairwise_counts(coyotecounts, fishercounts, "coyote", "fisher")
out4 <- pairwise_counts(lynxcounts,   martencounts, "lynx",   "marten")
out5 <- pairwise_counts(lynxcounts,   fishercounts, "lynx",   "fisher")
out6 <- pairwise_counts(martencounts, fishercounts, "marten", "fisher")

pairwise_summary <- rbind(out1, out2, out3, out4, out5, out6)
pairwise_summary

```

```{r}
species <- names(count_list)

pairs <- t(combn(species, 2))
colnames(pairs) <- c("sp1", "sp2")

overlap_results <- apply(pairs, 1, function(sp) {
  sum(presence_df[[sp[1]]] == 1 & presence_df[[sp[2]]] == 1)
})

overlap_df <- data.frame(
  sp1 = pairs[,1],
  sp2 = pairs[,2],
  overlap_sites = overlap_results
)

ggplot(overlap_df, aes(sp1, sp2, fill = overlap_sites)) +
  geom_tile() +
  geom_text(aes(label = overlap_sites)) +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Site Overlap Between Species")

```

#Load in covariate data

```{r}
covars <- read.csv("data/covars.csv")
```

```{r}

covars$PC1<-scale(covars$PC1)
covars$PC2<-scale(covars$PC2)
covars$hf<-scale(covars$hf)
covars$baited <- as.numeric(covars$baited)
```

##Frequentist N-mixture in unmarked
```{r}
umf_coyote <- unmarkedFramePCount(
  y = coyotecounts,
  siteCovs = covars
)

coyote_nmix <- pcount(
formula = ~ baited ~ 
  PC1 * hf + PC2 * hf,
data = umf_coyote,
mixture = "P"
)

coyote_nmix
plotEffects(coyote_nmix, "state", "PC1")
plotEffects(coyote_nmix, "state", "PC2")
plotEffects(coyote_nmix, "state", "hf")
plotEffects(coyote_nmix, "det", "baited")
```

#Lynx nmix abundance in unmarked
```{r}
umf_lynx <- unmarkedFramePCount(
  y = lynxcounts,
  siteCovs = covars
)

lynx_nmix <- pcount(
formula = ~ baited ~ 
  PC1 * hf + PC2 * hf,
data = umf_lynx,
mixture = "P"
)

lynx_nmix
plotEffects(lynx_nmix, type = "state", covariate = "PC1")
plotEffects(lynx_nmix, type = "state", covariate = "PC2")
plotEffects(lynx_nmix, type = "state", covariate = "hf")
plotEffects(lynx_nmix, "det", "baited")

```
#Marten nmix abundance in unmarked
```{r}
umf_marten <- unmarkedFramePCount(
  y = martencounts,
  siteCovs = covars
)

marten_nmix <- pcount(
formula = ~ 1 ~ 
  PC1 * hf + PC2 * hf,
data = umf_marten,
mixture = "P"
)

marten_nmix
plotEffects(marten_nmix, type = "state", covariate = "PC1")
plotEffects(marten_nmix, type = "state", covariate = "PC2")
plotEffects(marten_nmix, type = "state", covariate = "hf")
plotEffects(marten_nmix, "det", "baited")
```
#Fisher nmix abundance in unmarked
```{r}
umf_fisher <- unmarkedFramePCount(
  y = fishercounts,
  siteCovs = covars
)

fisher_nmix <- pcount(
formula = ~ baited ~ 
  PC1 * hf + PC2 * hf,
data = umf_fisher,
mixture = "P"
)

fisher_nmix
plotEffects(fisher_nmix, type = "state", covariate = "PC1")
plotEffects(fisher_nmix, type = "state", covariate = "PC2")
plotEffects(fisher_nmix, type = "state", covariate = "hf")
plotEffects(fisher_nmix, "det", "baited")
```

#Stan N-mixture using ubms
```{r}
umf_coyote <- unmarkedFramePCount(
  y = coyotecounts,
  siteCovs = covars
)

coyote_nmix_stan <- stan_pcount(formula =  ~ baited  ~ 
                       PC1 * hf + PC2 * hf,
                     data = umf_coyote,
                     chains = 3,
                     iter = 500,
                     cores = 3)

coyote_nmix_stan
plot_effects(coyote_nmix_stan, submodel = "state")
plot_effects(coyote_nmix_stan, submodel = "det")

traceplot(coyote_nmix_stan, pars=c("beta_state", "beta_det"))
plot_residuals(coyote_nmix_stan, submodel = "state")

plot_posteriors(coyote_nmix_stan)
```
```{r}
m <- coyote_nmix_stan
post <- as.data.frame(rstan::extract(m@stanfit))

abun <- post %>% 
  dplyr::select(starts_with("beta_state.")) %>%
  pivot_longer(everything(),
               names_to="parameter",
               values_to="value") %>%
  mutate(type = "Abundance (log-scale)")

det <- post %>% 
  dplyr::select(starts_with("beta_det.")) %>%
  pivot_longer(everything(),
               names_to="parameter",
               values_to="value") %>%
  mutate(type = "Detection (logit-scale)")

effects <- bind_rows(abun, det)

effects_summary <- effects %>%
  group_by(type, parameter) %>%
  summarise(
    mean = mean(value),
    LCI = quantile(value, 0.025),
    UCI = quantile(value, 0.975),
    .groups="drop"
  )

param_names <- names(coef(m))

effects_summary$names <- param_names

ggplot(effects_summary,
       aes(x = mean, y = names, color = type)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = LCI, xmax = UCI), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(x = "Parameter Estimate", y = "") +
  theme_bw() +
  theme(
    legend.position = "top",
    text = element_text(size = 14)
  )

```

```{r}
pc1data_lohf <- data.frame(
  PC1 = seq(min(covars$PC1, na.rm = TRUE),
           max(covars$PC1, na.rm = TRUE),
           length.out = 1000),
  PC2 = mean(covars$PC2, na.rm = TRUE),  # fix other covariates
  hf = quantile(covars$hf, 0.25, na.rm = TRUE)
)

pc1data_hihf <- data.frame(
  PC1 = seq(min(covars$PC1, na.rm = TRUE),
           max(covars$PC1, na.rm = TRUE),
           length.out = 1000),
  PC2 = mean(covars$PC2, na.rm = TRUE),  # fix other covariates
  hf = quantile(covars$hf, 0.75, na.rm = TRUE)
)

pred_coyote_pc1_lohf <- ubms::predict(
  coyote_nmix_stan,
  submodel = "state",
  species = "coyote",
  newdata = pc1data_lohf
)

pred_coyote_pc1_hihf <- ubms::predict(
  coyote_nmix_stan,
  submodel = "state",
  species = "coyote",
  newdata = pc1data_hihf
)

df_pc1_coyote <- data.frame(
  cov = pc1data_lohf$PC1,
  pred_lo = pred_coyote_pc1_lohf$Predicted,
  lower_lo = pred_coyote_pc1_lohf$`2.5%`,
  upper_lo = pred_coyote_pc1_lohf$`97.5%`,
  pred_hi = pred_coyote_pc1_hihf$Predicted,
  lower_hi = pred_coyote_pc1_hihf$`2.5%`,
  upper_hi = pred_coyote_pc1_hihf$`97.5%`
)

hf_labels <-  c(pred_lo = "darkgreen", pred_hi = "darkorange3")

coyote_pc1 <- ggplot(df_pc1_coyote, aes(x = cov)) +
  geom_ribbon(aes(ymin = lower_lo, ymax = upper_lo), fill = "darkgreen", alpha = 0.2) +
  geom_line(aes(y = pred_lo), color = "darkgreen", linewidth = 1) +
  geom_ribbon(aes(ymin = lower_hi, ymax = upper_hi), fill = "darkorange3", alpha = 0.2) +
  geom_line(aes(y = pred_hi), color = "darkorange3", linewidth= 1) +
  scale_color_manual(values = hf_labels) +
  labs(y = "Coyote occupancy probability",
       x = "Climate PC1",
       title = "Coyote abundance",
       colors = "Human footprint")+
  theme_classic()

coyote_pc1
```


#Custom N-mixture in Stan

```{stan}
// file: nmix_site_cam_orientation.stan
data {
  int<lower=1> S;                 // number of sites
  int<lower=1> C;                 // number of cameras (S * cams_per_site)
  int<lower=1> J;                 // number of sampling occasions (weeks)
  int<lower=1> K;                 // number of site-level abundance covariates (e.g., 4)
  matrix[S, K] X;                 // site covariate matrix (row = site)
  int<lower=1,upper=S> site_of_cam[C]; // map camera -> site (length C)
  int<lower=0> y[C, J];           // observed counts per camera x occasion
  int<lower=0,upper=1> baited[C, J]; // baited covariate per camera x occasion (0/1)
  int<lower=1> N_orient;          // number of orientation levels (e.g., 4)
  int<lower=1,upper=N_orient> orient[C]; // camera orientation level per camera (1..4)
  int<lower=0> Nmax_site[S];     // per-site Nmax to sum over (>= max observed at site)
}
parameters {
  // abundance (site-level)
  real alpha0;                    // intercept for log(lambda)
  vector[K] beta;                 // coefficients for site covariates
  vector[S] eta_site;             // site random intercepts (unscaled)
  real<lower=0> sigma_site;       // SD for site random effects

  // detection (camera x occasion)
  real gamma0;                    // detection intercept (logit scale)
  real gamma_bait;                // baited effect
  vector[N_orient] eta_orient;    // orientation random intercepts (unscaled)
  real<lower=0> sigma_orient;     // SD for orientation random effects
}
transformed parameters {
  vector[S] log_lambda;
  // site-level linear predictor for abundance
  log_lambda = alpha0 + X * beta + eta_site * sigma_site;
  // Note: eta_site is standard normal; we multiply by sigma_site either here or in model.
}
model {
  // Priors
  alpha0 ~ normal(0, 5);
  beta ~ normal(0, 2);
  eta_site ~ normal(0, 1);
  sigma_site ~ normal(0, 2); // half-normal

  gamma0 ~ normal(0, 5);
  gamma_bait ~ normal(0, 2);
  eta_orient ~ normal(0, 1);
  sigma_orient ~ normal(0, 2);

  // Likelihood: marginalize over latent N for each site
  for (s in 1:S) {
    // collect cameras that belong to site s
    // We'll compute log-likelihood contribution for site s by summing over N = max_obs..Nmax_site[s]
    int cams_for_s_count = 0;
    // create temporary arrays for p_ij and y_ij for the cameras in site s
    // To avoid dynamic arrays in Stan, we'll iterate over cameras and multiply inside loop.
    // For numerical stability, we'll compute the log marginal likelihood using log_sum_exp.

    // Determine minimal N to sum from: the largest count observed at any camera×occ in site s
    int ymax = 0;
    for (c in 1:C) if (site_of_cam[c] == s) {
      for (j in 1:J)
        if (y[c,j] > ymax) ymax = y[c,j];
    }

    real logpN[Nmax_site[s] - ymax + 1]; // log-probabilities for each candidate N
    int idx = 1;
    for (N = ymax; N <= Nmax_site[s]; N++) {
      // log P(N | lambda_s)
      real log_pN = poisson_lpmf(N | exp(log_lambda[s]));

      // add log P(y | N, p) for all cameras in site s and all occasions
      real log_py_given_N = 0;
      for (c in 1:C) if (site_of_cam[c] == s) {
        for (j in 1:J) {
          // build p for this camera and occasion:
          real logit_p = gamma0 + gamma_bait * baited[c,j] + eta_orient[orient[c]] * sigma_orient;
          real p = inv_logit(logit_p);
          // binomial_lpmf handles y up to N
          log_py_given_N += binomial_lpmf(y[c,j] | N, p);
        }
      }
      logpN[idx] = log_pN + log_py_given_N;
      idx += 1;
    }
    target += log_sum_exp(logpN); // add site marginal log-likelihood
  }
}
generated quantities {
  // posterior predictive draws or derived quantities can be added here
  // Example: mean abundance per site
  vector[S] lambda = exp(log_lambda);
}

```

```{r}
library(dplyr)
library(cmdstanr)   # recommended; faster than rstan
# or library(rstan) if you prefer

# --- assume you have a dataframe 'covars' with one row per camera:
# columns: location (camera name), location_id (site prefix), cam_orientation (NE/NW/SE/SW),
# PC1_site, PC2_site, hf_site, veg_site, baited (can be per camera or per camera×occasion)
# and a counts array or data.frame 'coyotecounts' with dimensions cameras x occasions

# Example: flatten/prepare
covars <- covars %>%
  mutate(
    # camera index
    cam_idx = row_number(),
    # orientation index 1..4
    orient_idx = match(cam_orientation, c("NE","NW","SE","SW"))
  )

# counts: suppose 'coyotecounts' is a matrix with rows in same order as covars rows
y_mat <- as.matrix(coyotecounts)  # dim = C x J

C <- nrow(y_mat)
J <- ncol(y_mat)

# site mapping: extract unique sites (site prefix) and map cameras to site index
site_names <- unique(covars$location_id)
S <- length(site_names)
site_of_cam <- match(covars$location_id, site_names)  # length C, values 1..S

# build site-level covariate matrix X (S x K)
# ensure covariates are site-level (one row per site)
site_covs <- covars %>% 
  group_by(location_id) %>% 
  summarise(
    PC1 = first(PC1_site),
    PC2 = first(PC2_site),
    hf  = first(hf_site),
    veg = first(veg_site)
  ) %>% ungroup()
X <- as.matrix(site_covs %>% select(PC1, PC2, hf, veg))

K <- ncol(X)

# baited should be camera x occasion matrix (0/1)
# if you have a single baited flag per camera:
baited_mat <- matrix(as.integer(covars$baited), nrow = C, ncol = J, byrow = FALSE)
# or if baiting changes by occasion, build accordingly.

# orientation vector per camera (1..4)
orient <- covars$orient_idx

# Nmax per site: choose max observed + buffer
Nmax_site <- integer(S)
for (s in 1:S) {
  cams <- which(site_of_cam == s)
  Nmax_site[s] <- max(y_mat[cams, ]) + 60  # buffer of 60; adjust as needed
}

# Prepare data list for Stan
stan_data <- list(
  S = S,
  C = C,
  J = J,
  K = K,
  X = X,
  site_of_cam = site_of_cam,
  y = y_mat,
  baited = baited_mat,
  N_orient = 4,
  orient = orient,
  Nmax_site = Nmax_site
)

# Compile & run with cmdstanr
mod <- cmdstan_model("nmix_site_cam_orientation.stan")
fit <- mod$sample(data = stan_data,
                  chains = 4, parallel_chains = 4,
                  iter_sampling = 1000, iter_warmup = 1000,
                  max_treedepth = 12, adapt_delta = 0.95)

print(fit$summary())

```


#Multi N-mixture
````{r}
abund.ms.formula <- ~ PC1 * hf + PC2 * hf
det.ms.formula <- ~ baited
```